---
title: 00_ETL
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: load packages

library(tidyverse)
library(pointblank)
library(janitor)
```


Import data
```{r}
#| label: load data
#| cache: true

inspections_raw <- readr::read_csv("https://data.cityofchicago.org/api/views/4ijn-s7e5/rows.csv")
bus_data_raw <- readr::read_csv("https://data.cityofchicago.org/api/views/r5kz-chrr/rows.csv")

```

Inspect the data
```{r}
#| label: Data scan

scan <- pointblank::scan_data(inspections_raw, sections = "OVMS")
scan
# Note the sections argument. We omit "Correlations" and "Interactions" because these aren't relevant for this dataset and take a long time to run on this large of a dataset.

```

Explore the data scan.

1. What is the most common value for `dba_name` and `AKA Name` (hint: Toggle details)
1. Explore the `facility_type`. What values should we consider filtering out or preserving?
1. Are there columns that we should cross reference for validation?

First pass thin out the data
```{r}
#| label: thin out data

# When we inspect the Facility Type, we see there is a lot of variation in how the inspector recorded this data. It certainly doesn't align with the stated possible values in the data dictionary. For example: 
inspections_raw |> filter(grepl("rest", `Facility Type`, ignore.case = TRUE)) |> group_by(`Facility Type`) |> tally() |> arrange(desc(n))
inspections_raw |> filter(grepl("bakery", `Facility Type`, ignore.case = TRUE)) |> group_by(`Facility Type`) |> tally() |> arrange(desc(n))
inspections_raw |> filter(grepl("coffee", `Facility Type`, ignore.case = TRUE)) |> group_by(`Facility Type`) |> tally() |> arrange(desc(n))

# We'd like the following types: Restaurant, Bakery, Coffee Shop. And The Wrigley Field Rooftop sounds like a blast.  We'll filter the Facility Type based on regex to account for abbreviations, mis-spellings, and extra information. This is a coarse filter on the raw data before validation to thin out the dataset.  Also, let's clean up column names and convert entries to UPPERCASE for consistency
inspections <- inspections_raw |> 
  # clean column names with the `janitor` package
  clean_names() |> 
  # convert to UPPERCASE
  mutate(across(where(is.character), toupper)) |> 
  filter(
    # Filter for "RESTAURANTS" and variations including "REST", "RSTRNT", etc.
    grepl("RE?STA?U?R?A?N?T?", `facility_type`) | 
    # OR Filter for "BAKERY" and variations to account for typos or shortenings
    grepl("BA?KE?R?Y?", `facility_type`) | 
    # OR Filter for "COFFEE SHOP" and variations, but consciously including "SHOP" to avoid carts, roasters, vending machines
    grepl("COFFEE *SHOP", `facility_type`) | 
    # OR Filter for "WRIGLEY"
    grepl("WRIGLEY", `facility_type`)
    )


```
Question - what should we just filter out vs. identify by data validation?  What do we want to flag for data quality issues?

Perform data validation
```{r}
#| label: data validation

# Define a column schema so we can check inputted data is as expected
# Fun fact, also use .tbl argument in col_schema to compare the dataframe to an ideal table.
# troubleshooting, if this fails, look at the x_list$col_types and $col_names to see the discrepancy
schema_inspections <- col_schema(inspection_id = "numeric",
                               dba_name = "character",
                               aka_name = "character",
                               license_number = "numeric",
                               facility_type = "character",
                               risk = "character",
                               address = "character",
                               city = "character",
                               state = "character",
                               zip = "numeric",
                               inspection_date = "character",
                               inspection_type = "character",
                               results = "character",
                               violations = "character",
                               latitude = "numeric",
                               longitude = "numeric",
                               location = "character")

# 

# can do validations before and after a join between bus_data and inspections to be sure the join was successful.

# warning levels:
# hard stop on failed join and on not enough rows in inspections. 
# otherwise sunder the data and move on

agent <- 
  create_agent(inspections) |> 
  # verify column schema
  col_schema_match(schema_inspections) |> 
  #Add in a check that all column names exist. We make a table in the preconditions using a table transform that is made up of the column names of our inspections table. Then compare those values to the set of schema_inspection names.
  col_vals_in_set(columns = value,set = names(schema_inspections), preconditions = ~. %>% tt_tbl_colnames ) |> 
  # verify there are A LOT of rows of data to be sure import didn't mess up
  
  # verify values not null for inspection_id, dba_name, address, inspection_date, inspection_type, results -- do this individually so I can see the detailed results
  
  # verify values not missing for same columns above
  
  # verify lat and long bounds
  
  # verify w col_vals_within_spec for postal_code / aka zip
  
  # verify threshold between location lat / long is less than a small value
  
  # find a reason to use serially()

  # compare DBA name to bus_lic_dba name and see that it isnt too far off. Use license key as the join. and stringdist

  # verify inspection ID is unique
  # rows_distinct(vars(inspection_id)) |> 
  # # verify inspection ID is valid
  # col_vals_between(vars(inspection_id), 1000, 99999999) |> 
  interrogate() 

agent
all_passed(agent_schema)

# invalid data entry 

# value ranges




```



Informant table / Data Dictionary 
```{r}
#| label: data dictionary

create_informant(
  tbl = inspections_raw,
  tbl_name = "Data Dictionary - Chicago Food Inspection Dataset",
  label = "Data Dictionary - Chicago Food Inspection Dataset") |> 
  info_tabular(
    description = "This table defines the columns in the City of Chicago Food Inspection dataset"
  ) |> 
  info_section(
    section_name = "further information",
    `source` = "Data from City of Chicago, <http://www.cityofchicago.org>",
    `üîÑ updates` = "Original data source updated every Friday. This table last updated {Sys.Date()}.",
    `‚ÑπÔ∏è note` = "This example material using data that has been modified for use from its original source, <www.cityofchicago.org>, the official website of the City of Chicago.  The City of Chicago makes no claims as to the content, accuracy, timeliness, or completeness of any of the data provided at this site.  The data provided at this site is subject to change at any time.  It is understood that the data provided at this site is being used at one's own risk."
  ) |> 
  info_columns(
    columns = "Inspection ID",
    `‚ÑπÔ∏è` = "A unique record number."
  ) |> 
  info_columns(
    columns = "DBA Name",
    `‚ÑπÔ∏è` = "'Doing Business As.' This is legal name of the establishment."
  ) |> 
  info_columns(
    columns = "AKA Name",
      `‚ÑπÔ∏è` = "'Also Known As.' This is the name the public would know the establishment as."
  ) |> 
  info_columns(
    columns = "License #",
      `‚ÑπÔ∏è` = "This is a unique number assigned to the establishment for the 
purposes of licensing by the Department of Business Affairs and Consumer Protection."
  ) |>  
  info_columns(
    columns = "Facility Type",
      `‚ÑπÔ∏è` =
      "Each establishment is described by one of the following: \n - bakery","banquet hall \n - candy store \n - caterer \n - coffee shop \n - day care center (for ages less than 2) \n - day care center (for ages 2 ‚Äì 6) \n - day care center (combo, for ages less than 2 and 2 ‚Äì 6 combined) \n - gas station \n - Golden Diner \n - grocery store \n - hospital \n - long term care center(nursing home) \n - liquor store \n - mobile food dispenser \n - restaurant \n - paleteria \n - school \n - shelter \n - tavern \n - social club \n - wholesaler \n - Wrigley Field Rooftop"
  )  |>
  info_columns(
    columns = "Risk",
      `‚ÑπÔ∏è` = "Risk category of facility: Each establishment is categorized as to its risk of adversely affecting the public's health, with 1 being the highest and 3 the lowest. The frequency of inspection is tied to this risk, with risk 1 establishments inspected most frequently and risk 3 least frequently."
  ) |>  
  info_columns(
    columns = "Address",
      `‚ÑπÔ∏è` = "Street address, city, state and zip code of facility: This is the complete address where the facility is located."
  ) |>  
  info_columns(
    columns = "City",
      `‚ÑπÔ∏è` = "City of the facility."
  ) |>  
  info_columns(
    columns = "State",
      `‚ÑπÔ∏è` = "State of the facility."
  ) |>  
  info_columns(
    columns = "Zip",
      `‚ÑπÔ∏è` = "Zip Code of the facility."
  ) |>  
  info_columns(
    columns = "Inspection Date",
      `‚ÑπÔ∏è` = "This is the date the inspection occurred. A particular establishment is likely to have multiple inspections which are denoted by different inspection dates."
  ) |>  
  info_columns(
    columns = "Inspection Type",
      `‚ÑπÔ∏è` = "An inspection can be one of the following types: canvass, the most common type of inspection performed at a frequency relative to the risk of the establishment; consultation, when the inspection is done at the request of the owner prior to the opening of the establishment; complaint, when  the inspection is done in response to a complaint against the establishment; license, when the inspection is done as a requirement for the establishment to receive its license to operate; suspect food poisoning, when the inspection is done in response to one or more persons claiming to have gotten ill as a result of eating at the establishment (a specific type of complaint-based inspection); task-force inspection, when an inspection of a bar or tavern is done. Re-inspections can occur for most types of these inspections and are indicated as such."
  ) |>  
  info_columns(
    columns = "Results",
      `‚ÑπÔ∏è` = "An inspection can pass, pass with conditions or fail. Establishments receiving a 'pass' were found to have no critical or serious violations (violation number 1-14 and 15-29, respectively). Establishments receiving a 'pass with conditions' were found to have critical or serious violations, but these were corrected during the inspection. Establishments receiving a 'fail' were found to have critical or serious violations that were not correctable during the inspection. An establishment receiving a 'fail' does not necessarily mean the establishment's licensed is suspended. Establishments found to be out of business or not located are indicated as such."
  ) |>  
  info_columns(
    columns = "Violations",
      `‚ÑπÔ∏è` = "An establishment can receive one or more of 45 distinct violations (violation numbers 1-44 and 70). For each violation number listed for a given establishment, the requirement the establishment must meet in order for it to NOT receive a violation is noted, followed by a specific description of the findings that caused the violation to be issued."
  ) |>  
  info_columns(
    columns = "Latitude",
      `‚ÑπÔ∏è` = "The Latitude of the facility."
  ) |>
  info_columns(
    columns = "Longitude",
      `‚ÑπÔ∏è` = "The Longitude of the facility."
  ) |>
  info_columns(
    columns = "Location",
      `‚ÑπÔ∏è` = "The Latitude and Longitude of the facility."
  ) |>
  incorporate()


```

Use email_create() to make a blastula object 

```{r}
#| label: unused code
#| include: false
#| eval: false

# This function removes text in parentheses. When in the Facility Type, this only obfuscates the Type
strip_parens <- function(x) {
  x |> str_remove_all("(?=\\().*?(?<=\\))") |> 
    str_squish()
}

# the expected facility types
ref_types <- tibble(`Facility Type` = c("bakery","banquet hall", "candy store", "caterer", "coffee shop", "day care center", "gas station", "Golden Diner", "grocery store", "hospital", "long term care center", "nursing home", "liquor store", "mobile food dispenser", "restaurant", "paleteria", "school", "shelter", "tavern", "social club", "wholesaler", "Wrigley Field Rooftop") )

facilities <- 
  inspections_raw |> 
  select(`Facility Type`) |> 
  # bind_rows(ref_types) |>
  mutate(`Facility Type` = str_to_lower(`Facility Type`)) |> 
  mutate(`Facility Type` = strip_parens(`Facility Type`)) |> 
  filter(!is.na(`Facility Type`)) |>
  distinct() 

compare <- tidy_comb_all(facilities,`Facility Type`)

comparisons <- tidy_stringdist(compare) |> 
  mutate(sim = 1-jaccard) |> 
  select(V1, V2, sim)

recommendation <- comparisons |> 
  group_by(V1) |> 
  summarise(max_sim = max(sim)) |> 
  ungroup()

comparisons |> 
  inner_join(recommendation, by = c("V1" = "V1", "sim" = "max_sim"))


```

