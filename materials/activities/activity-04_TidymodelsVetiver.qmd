---
title: "Introduction to Tidymodels & Vetiver"
description: "Create, deploy, and monitor a model that predicts the price of diamonds (`ggplot2::diamonds`) using Tidymodels & Vetiver."
toc: true
toc-depth: 4
editor_options: 
  chunk_output_type: console
execute: 
  eval: false
---

::: callout-note
## [Vetiver](https://vetiver.rstudio.com/) is an open source tool for versioning, deploying, and monitoring a trained model.
:::

![](https://vetiver.rstudio.com/images/ml_ops_cycle.png){fig-align="center" width="422"}

## Setup

```{r}
#| label: load-packages

library(tidymodels)
library(tidyverse)
library(vetiver)
library(pins)
library(plumber)
library(rsconnect)

tidymodels::tidymodels_prefer()
```

## Goals

In this notebook, you will use get practice:

-   Creating a simple machine learning model using [tidymodels](https://www.tidymodels.org/).

-   Save the model as a [pin](https://pins.rstudio.com/) to Posit Connect using Vetiver.

-   Serve the model as a [Plumber API](https://www.rplumber.io/) using Vetiver.

## Activity 1 - Create a tidymodel

[Tidymodels](https://www.tidymodels.org/) is a collection of R packages for modeling and machine learning using [tidyverse](https://www.tidyverse.org/) principles. While this workshop is **not** a modeling workshop, to demonstrate the utility of the Vetiver, we need to create a model. Let's use the `diamonds` dataset to create a linear regression model.

For this activity, we will train and fit the model on most of the diamonds dataset, but we'll extract a small subset to replicate "new" data for model monitoring.

ðŸ”„ Tasks

-   Explore the `diamonds` dataset. Use any method you'd like to understand the data (even if you know the `diamonds` dataset back and forth ðŸ˜‰).

-   Create a tidymodel that predicts `price` based on every other column in the dataset using linear regression.

âœ… Solutions

#### Explore the `diamonds` dataset

```{r}
# Options for exploring the diamonds dataset

diamonds # simple print
glimpse(diamonds) # more info about each column
str(diamonds)
```

### Train a model to predict `price`

Within the `workflow()` function below, you will add two arguments. The first is the formula for the model, and the second will be the type of model you want to use. For the formula, we would like you to predict the `price` of diamonds based on every other column in the dataset (represented by a `.`). And to start, we'll use linear regression (`linear_reg()`).

Next, fit the workflow to the data (`diamonds_train`). As a reminder, we sliced the last 100 rows of the raw diamonds dataset to replicate "new" data that will be used later on.

```{r}
# Extract the last 100 rows for model monitoring
diamonds_train <- diamonds |> slice_tail(n = -100)
diamonds_new <- diamonds |> slice_tail(n = 100)

model_recipe <- recipes::recipe(price ~ ., data = diamonds_train)
model_type <- parsnip::linear_reg()
model_wflow <- workflows::workflow(model_formula, model_type)

# Fit the model to data
model_fit <- fit(model_wflow, diamonds_train)
```

## Activity 2 - Create and Deploy a Vetiver model

Creating a model is an exciting step in many data science workflows. However, sharing the model with others, or integrating it with other steps in your workflow can be challenging. Thankfully, Vetiver makes this super easy. In the following activity, you will create a Vetiver model and then deploy it to Posit Connect.

ðŸ”„ Task

-   Create a Vetiver model.

-   Deploy Vetiver model to Posit Connect.

âœ… Solutions

### Create a Vetiver model

Add in the name of your model and give your Vetiver model a name (`"first_name/name_of_model"`).

```{r}
v <- vetiver_model(model = price_fit, model_name = "ryan/diamonds_price")
```

### Save Vetiver model to Posit Connect

In the code chunk below, we will take the Vetiver model we just created and save it to Posit Connect. Vetiver does this by using the `pins` R package. Before we can save, or pin, the model to Posit Connect, we first must *register* the Connect instance as our "board".

Add the function from the `pins` package to register Posit Connect as our board, and then write the Vetiver model to Posit Connect by adding the name of the board and Vetiver model.

```{r}
# Register Posit Connect
connect_board <- pins::board_connect()

# Deploy to Posit Connect
vetiver_pin_write(board = connect_board, vetiver_model = v)
```

Now that the model is saved (or "pinned") to Posit Connect, you can easily read it into whatever piece of content your creating!

## Assignment 3 - Serve model as a Plumber API

APIs are a great way for users, applications, or other systems to interact with your model. Vetiver leverages [Plumber](https://www.rplumber.io/) which is used to create API with only R code! Let's create an API here within Posit Workbench, and then deploy it to Posit Connect.

ðŸ”„ Task

-   Create a Plumber API using Vetiver.

-   Make a prediction using the API visual interface (RapiDoc).

-   Publish the API to Posit Connect and set it to `Anyone - no login required`.

âœ… Solutions

### Create a Plumber API using Vetiver

```{r}
plumber::pr() |> 
  vetiver_api(vetiver_model = v) |> 
  pr_run()
```

Once the plumber API is running, you should see a RapiDoc which is a visual way to interact with the API. Try making a prediction by: clicking the Post endpoint --\> Example tab --\> modify the text box with values as you see fit --\> Try!

### Publish the API to Posit Connect

Add the name of the board and the name of the pinned model on Posit Connect.

```{r}
vetiver_deploy_rsconnect(board = connect_board, name = "ryan/diamonds_price")
```

Navigate to your API now running on Posit Connect and give it a test run! It's also possible to restrict access to your API by modifying the access setting on Connect. In this case, users of your API would need to supply an API key using the `httr` package. For now, let's set the API to `Anyone - no login required`. For more information on API access control, see the Posit docs [here](https://docs.posit.co/connect/user/vetiver/#predict-from-your-model-endpoint).

## Assignment 4 - Interact with your Model

Now that the model is being served as a Plumber API and hosted on Posit Connect, we can use the Vetiver package to easily interact with the API using R code!

ðŸ”„ Task

-   Save the `predict` API endpoint.

-   Make a prediction using R code.

âœ… Solutions

### Save the `/predict` API endpoint

```{r}
api_url <- "<-- add your API URL here -->"

endpoint <- vetiver_endpoint(paste0(api_url, "/predict"))

endpoint
```

### Make a prediction using R code

```{r}
new_diamond <- tibble(carat = 0.8,  
                      cut = "Good", 
                      color = "J",
                      clarity = "VS2",
                      depth = 61.2,
                      table = 55,
                      x = 4.02,
                      y = 4.32,
                      z = 2.64)

predict(endpoint, new_diamond)
```

## Activity 5 - Version and monitor you models

Creating a model is an iterative process, and chances are you'll create multiple versions of your model along the way. You may even create a completely different model to address the same question. How then can you keep track of all these versions, and ensure that you're always using the best model for the job? Vetiver to the rescue ðŸ¦¸!

Before we get started, we first need to make sure that the board we are using to pin our models can accommodate versioning. Fortunately, most boards, including Posit Connect, leverage versioning by default. If you want to explicitly turn on versions, just make sure you use the `versioned` argument when defining your board: `board_connect(versioned = TRUE)`.

Monitoring a model means you are assessing performance as new data comes in over time. Even though our `diamonds` data does not have a date feature, we need someway to tell the model that "this new diamond was measured on this date." For this example, we will create a "fake" date for each row in our new (testing) data.

ðŸ”„ Task

-   Create and save a second model using a decision tree.

-   Monitor models.

âœ… Solutions

### Create and save a second model using a decision tree

Let's create a another model that predicts the same thing as before (price of diamonds) but uses a decision tree instead.

This model will overwrite our previous linear regression model...and that's OK! Fill in the blanks below.

```{r}
# Fit a decision tree
price_fit <-
    workflow(price ~ ., decision_tree(mode = "regression")) %>%
    fit(diamonds_train)

# Create a vetiver model
v <- vetiver_model(model = price_fit, model_name = "ryan/diamonds_price")

# Pin the new model to same location
vetiver_pin_write(board = connect_board, vetiver_model = v)

# View both version of you model
pin_versions(board = connect_board, name = "ryan/diamonds_price")
```

### Monitor models

Here is where the `diamonds_new` data comes into play! Again, for monitoring, we need some sense of *time* for this new data, so we will add a fake date column to the `diamonds_new` dataset.

```{r}
# Add a "fake" date column to our new data
start_date <- as_date("2022-01-01")
end_date <- as_date("2023-01-01")


diamonds_new <- diamonds_new |> 
  rowwise() |> 
  mutate(date_obs = sample(seq(start_date, end_date, by = "day"), 
                           size = 1, 
                           replace = FALSE)) |> 
  arrange(date_obs) |> 
  ungroup()
```

Now that we have a date associated with each row of *new* diamonds data, let's compare how well our two models (linear regression & decission tree) did at predicting the price of these new diamonds. We will collect two metrics: `rmse` and `mae`. You can read about those [here](https://www.tmwr.org/performance#performance) if interested!

```{r}
# Collect metrics (rmse and mae) on diamonds test data
augment(vetiver_pin_read(connect_board,
                         "ryan/diamonds_price",
                         version = "_____"), # add in the version number for decision tree
        new_data = diamonds_new) |> 
  vetiver_compute_metrics(date_var = date_obs, 
                        period = "month", 
                        truth = price,  
                        estimate = .pred,
                        metric_set = metric_set(rmse, mae)) |> 
  vetiver_plot_metrics()
```

```{r}
# Calculate metrics on linear regression model
augment(vetiver_pin_read(connect_board,
                         "ryan/diamonds_price",
                         version = "_____"), # add in the correct 
        new_data = diamonds_new) |> 
  vetiver_compute_metrics(date_var = date_obs, 
                        period = "month", 
                        truth = price,  
                        estimate = .pred,
                        metric_set = metric_set(rmse, mae)) |> 
  vetiver_plot_metrics()

```
