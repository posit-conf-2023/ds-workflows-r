---
title: "Introduction to Tidymodels & Vetiver"
description: "Create, deploy, and monitor a model that predicts the price of diamonds (`ggplot2::diamonds`) using Tidymodels & Vetiver."
toc: true
toc-depth: 4
editor_options: 
  chunk_output_type: console
execute: 
  eval: false
---

::: callout-note
## [Vetiver](https://vetiver.rstudio.com/) is an open source tool for versioning, deploying, and monitoring a trained model.
:::

![](https://vetiver.rstudio.com/images/ml_ops_cycle.png){fig-align="center" width="422"}

## Setup

```{r}
#| label: load-packages

library(tidymodels)
library(tidyverse)
library(vetiver)
library(pins)
library(plumber)
library(rsconnect)

tidymodels::tidymodels_prefer()
```

## Goals

In this notebook, you will use get practice:

-   Creating a simple machine learning model using [tidymodels](https://www.tidymodels.org/).

-   Save the model as a [pin](https://pins.rstudio.com/) to Posit Connect using Vetiver.

-   Serve the model as a [Plumber API](https://www.rplumber.io/) using Vetiver.

‚úèÔ∏è There will be placeholders (`____`) in the code cells below that you will need to fill in!

## Activity 1 - Create a tidymodel

[Tidymodels](https://www.tidymodels.org/) is a collection of R packages for modeling and machine learning using [tidyverse](https://www.tidyverse.org/) principles. While this workshop is **not** a modeling workshop, to demonstrate the utility of the Vetiver, we need to create a model. Let's use the `diamonds` dataset to create a linear regression model.

For this activity, we will train and fit the model on most of the diamonds dataset, but we'll extract a small subset to replicate "new" data for model monitoring.

üîÑ Tasks

-   Explore the `diamonds` dataset. Use any method you'd like to understand the data (even if you know the `diamonds` dataset back and forth üòâ). Try functions like `glimpse()` and `str()`.

-   Create a tidymodel that predicts `price` based on every other column in the dataset using linear regression. Refer to the slides for guidance.

‚úÖ Solutions

#### Explore the `diamonds` dataset

```{r}
# Use the space below to explore the diamonds dataset

```

### Train a model to predict `price`

Within the `workflow()` function below, you will add two arguments. The first is the formula for the model, and the second will be the type of model you want to use. For the formula, we would like you to predict the `price` of diamonds based on every other column in the dataset (represented by a `.`). And to start, we'll use linear regression (`linear_reg()`).

Next, fit the workflow to the data (`diamonds_train`). As a reminder, we sliced the last 100 rows of the raw diamonds dataset to replicate "new" data that will be used later on.

```{r}
# Extract the last 100 rows for model monitoring
diamonds_train <- diamonds |> slice_tail(n = -100)
diamonds_new <- diamonds |> slice_tail(n = 100)

# Create Recipe 
model_recipe <- recipes::recipe(____, data = diamonds_train)

# Define model using parsnip (ex. linear_reg())
model_type <- parsnip::____

# Combine recipe and model type into a workflow
model_wflow <- workflows::workflow(____, ____)

# Fit the model to data
model_fit <- fit(____, diamonds_train)
```

## Activity 2 - Create and Deploy a Vetiver model

Creating a model is an exciting step in many data science workflows. However, sharing the model with others, or integrating it with other steps in your workflow can be challenging. Thankfully, Vetiver makes this super easy. In the following activity, you will create a Vetiver model and then deploy it to Posit Connect.

üîÑ Task

-   Create a Vetiver model.

-   Deploy Vetiver model to Posit Connect.

‚úÖ Solutions

### Create a Vetiver model

Add in the name of your model and give your Vetiver model a name.

```{r}
v <- vetiver_model(model = ____, model_name = "____")
```

### Save Vetiver model to Posit Connect

In the code chunk below, we will take the Vetiver model we just created and save it to Posit Connect. Vetiver does this by using the `pins` R package. Before we can save, or pin, the model to Posit Connect, we first must *register* the Connect instance as our "board".

Add the function from the `pins` package to register Posit Connect as our board, and then write the Vetiver model to Posit Connect by adding the name of the board and Vetiver model.

```{r}
# Register Posit Connect
connect_board <- pins::____

# Deploy to Posit Connect
vetiver_pin_write(board = ____, vetiver_model = "____")
```

Now that the model is saved (or "pinned") to Posit Connect, you can easily read it into whatever piece of content your creating!

## Assignment 3 - Serve model as a Plumber API

APIs are a great way for users, applications, or other systems to interact with your model. Vetiver leverages [Plumber](https://www.rplumber.io/) which is used to create API with only R code! Let's create an API here within Posit Workbench, and then deploy it to Posit Connect.

üîÑ Task

-   Create a Plumber API using Vetiver.

-   Make a prediction using the API visual interface (RapiDoc).

-   Publish the API to Posit Connect and set it to `Anyone - no login required`.

‚úÖ Solutions

### Create a Plumber API using Vetiver

The below code is will take your Vetiver model, and turn it into an API using the `plumber` package. Add your Vetiver model to the code below and then run the code cell!

```{r}
plumber::pr() |> 
  vetiver_api(vetiver_model = ____) |> 
  pr_run()
```

Once the plumber API is running, you should see a RapiDoc which is a visual way to interact with the API. Try making a prediction by: clicking the Post endpoint --\> Example tab --\> modify the text box with values as you see fit --\> Try! See image below for an example:

![](images/vetiver_api_example.png){fig-align="center" width="498"}

### Publish the API to Posit Connect

Add the name of the board and the name of the pinned model on Posit Connect. Notice that when you pinned the model above (`vetiver_pin_write()`), your Posit Connect name was added to the pin name. For example, `ryan/name_of_pin`. If you are unsure of the full name of the pinned model, then navigate to Posit Connect and view the published pin.

```{r}
vetiver_deploy_rsconnect(board = ____, name = "____")
```

Navigate to your API now running on Posit Connect and give it a test run! It's also possible to restrict access to your API by modifying the access setting on Connect. In this case, users of your API would need to supply an API key using the `httr` package. For more information on API access control, see the Posit docs [here](https://docs.posit.co/connect/user/vetiver/#predict-from-your-model-endpoint).

## Assignment 4 - Interact with your Model

Now that the model is being served as a Plumber API and hosted on Posit Connect, we can use the Vetiver package to easily interact with the API using R code!

üîÑ Task

-   Save the `predict` API endpoint.

-   Make a prediction using R code.

‚úÖ Solutions

### Save the `/predict` API endpoint

On Posit Connect, navigate to your newly created API, and copy the URL for the content below. You can find this URL by clicking the access tab --\> URL.

```{r}
api_url <- "____"

endpoint <- vetiver_endpoint(paste0(api_url, "/predict"))

endpoint
```

### Make a prediction using R code

Add in some fake data for a "new" diamond, and run the code below. When you run the `predict()` function, **you might get an error!** This is likely because the API is not "open access" and requires that an API key be provided.

```{r}
new_diamond <- tibble(carat = ____,  
                      cut = "____", 
                      color = "____",
                      clarity = "____",
                      depth = ____,
                      table = ____,
                      x = ____,
                      y = ____,
                      z = ____)

predict(endpoint, new_diamond)
```

If you'd like to learn more about creating API keys on Posit Connect, check out the link [here](https://docs.posit.co/connect/user/vetiver/#predict-from-your-model-endpoint). But for now, try setting the API access controls on Connect to `Anyone - no login required` and then re-run the code above.

## Activity 5 - Version and monitor you models

Creating a model is an iterative process, and chances are you'll create multiple versions of your model along the way. You may even create a completely different model to address the same question. How then can you keep track of all these versions, and ensure that you're always using the best model for the job? Vetiver to the rescue ü¶∏!

Before we get started, we first need to make sure that the board we are using to pin our models can accommodate versioning. Fortunately, most boards, including Posit Connect, leverage versioning by default. If you want to explicitly turn on versions, just make sure you use the `versioned` argument when defining your board: `board_connect(versioned = TRUE)`.

Monitoring a model means you are assessing performance as new data comes in over time. Even though our `diamonds` data does not have a date feature, we need someway to tell the model that "this new diamond was measured on this date." For this example, we will create a "fake" date for each row in our new (testing) data.

üîÑ Task

-   Create and save a second model using a decision tree.

-   Monitor models.

‚úÖ Solutions

### Create and save a second model using a decision tree

Let's create a another model that predicts the same thing as before (price of diamonds) but uses a decision tree instead.

This model will overwrite our previous linear regression model pinned to Posit Connect...and that's OK! Fill in the `____`'s below.

```{r}
# Create another recipe (saved as model_recipe2)
model_recipe2 <- recipes::recipe(____, data = diamonds_train)

# Create another model type (decision_tree(mode = "regression"))
model_type2 <- parsnip::____

# Combine the recipe and model type into a new woriflow
model_wflow2 <- workflow(____, ____)

# Fit the model to data
model_fit2 <- fit(____, diamonds_train)

# Create a vetiver model (use the same name as before)
v2 <- vetiver_model(model = ____, model_name = "____")

# Pin the new model to same location
vetiver_pin_write(board = ____, vetiver_model = ____)

# View both versions of your model
pin_versions(board = ____, name = "____")
```

### Monitor models

Here is where the `diamonds_new` data comes into play! Again, for monitoring, we need some sense of *time* for this new data, so we will add a fake date column to the `diamonds_new` dataset. Take a look at the code below, but all you need to do is run it (no `___`'s to fill in).

```{r}
# Add a "fake" date column to our new data
start_date <- as_date("2022-01-01")
end_date <- as_date("2023-01-01")


diamonds_new <- diamonds_new |> 
  rowwise() |> 
  mutate(date_obs = sample(seq(start_date, end_date, by = "day"), 
                           size = 1, 
                           replace = FALSE)) |> 
  arrange(date_obs) |> 
  ungroup()
```

Now that we have a date associated with each row of *new* diamonds data, let's compare how well our two models (linear regression & decision tree) did at predicting the price of these new diamonds. We will collect two metrics: `rmse` and `mae`. You can read about those [here](https://www.tmwr.org/performance#performance) if interested!

```{r}
# Collect metrics (rmse and mae) on diamonds test data
augment(vetiver_pin_read(connect_board,
                         "ryan/diamonds_price",
                         version = "____"), # add in the version number for linear regression
        new_data = diamonds_new) |> 
  vetiver_compute_metrics(date_var = date_obs, 
                        period = "month", 
                        truth = price,  
                        estimate = .pred,
                        metric_set = metric_set(rmse, mae)) |> 
  vetiver_plot_metrics()
```

```{r}
# Calculate metrics on linear regression model
augment(vetiver_pin_read(connect_board,
                         "ryan/diamonds_price",
                         version = "____"), # add in the version number for decission tree
        new_data = diamonds_new) |> 
  vetiver_compute_metrics(date_var = date_obs, 
                        period = "month", 
                        truth = price,  
                        estimate = .pred,
                        metric_set = metric_set(rmse, mae)) |> 
  vetiver_plot_metrics()

```
