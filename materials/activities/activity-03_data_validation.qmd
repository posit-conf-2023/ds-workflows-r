---
title: "activity-03_data_validation.qmd"
description: "This notebook performs data validation using `pointblank`"
toc: true
toc-depth: 4
editor: visual
editor_options: 
  markdown:
    wrap: 72
    canonical: true
execute: 
  eval: false
---

## Goals

The goals of this activity are to:

-   Use the `pointblank` package to perform data validations

-   Define thresholds in data validation to be used for alerting

-   Create an informant data dictionary

✏️ There will be placeholders (`____`) in the code cells below that you
will need to fill in!

## Setup

### Load required packages for data validation

```{r}
#| label: Load packages

library(tidyverse)
library(pointblank)

```

### Read data from pin

We are going to start with a data set called `inspections_filtered`.
This data is an extract from the original `inspections_raw` data set,
which has been filtered to only include records of interest.
Specifically, it only includes inspection records that were marked as
"Pass", "Fail", or "Pass w/ Conditions" from the following Facility
Types:

\- Restaurants

\- Grocery Stores

\- Bakeries

\- Coffee Shops

\- Wrigley Field Rooftop (because that sounds pretty fun)

This data has been saved for you as a pin.

::: callout-note
## [pins](https://pins.rstudio.com/) is a package for R and Python that makes it easy to share objects (e.g., data frames, models) across projects and team members.
:::

![](https://pins.rstudio.com/logo.png){fig-align="center" width="212"}

📌 Objects in R and Python can be "pinned" to a "board" so that they are
easily shared

📌 The board is like a virtual corkboard, your object is pinned with a
virtual thumbtack

📣 Pin intermediate data and objects, not your source of truth. Pins are
not a substitute for a database

📌 When the board is Posit Connect, the same access controls for content
can be applied

📌 We will talk more about pins during the Modeling section of this
workshop!

```{r read-data-from-pin}

# Define the virtual corkboard. Do not add any arguments to this code; run as-is.
board <- pins::board_connect()

# Read the existing pin with the data we'll use for this exercise.
inspections_filtered <- board |> 
  pins::pin_read("katie.masiello/inspections_filtered")

inspections_filtered

```

## Task 1 - Data validation on `inspections_filtered`

🔄 Task

Use the `pointblank` package to validate our `inspections_filtered`
dataset

-   create an agent
-   define validations
-   interrogate the table

✅ Solution

The first step in the `pointblank` workflow is to create an **agent.**

```{r}
#| label: create agent for inspections_filtered

agent <- pointblank::create_agent(____)
agent
```

On its own, the agent is not very informative. It's waiting for
validations to be defined and an interrogation action to be performed.

Now we define our **data validation functions**. A few have been started
for you as examples. Create your own and explore! Refer to the package
documentation for the validation function reference:
<https://rstudio.github.io/pointblank/reference/index.html#validation-expectation-and-test-functions>

```{r}
#| label: define validations for inspections_filtered

agent <- agent |> 
  # verify inspection ID is between two arbitrary numbers so we can see some failed records
  col_vals_between(columns = inspection_id, 50000, 1000000, 
                   label = "Is the Inspection ID a valid entry?") |> 
  # verify license number is greater than 1000
  col_vals_gt(columns = license_number, 1000) |> 
  # verify inspection date is valid
  col_vals_lte(columns = inspection_date, today(),
               label = "Is inspection date in the past?") |> 
  # Now add your own!
  ____ |> 
  ____

agent

```

If we look at the output of `agent`, it shows our validation plan, but
the action is yet to come when we **interrogate**.

```{r}
#| label: interrogate the inspections_filtered agent

agent |> interrogate()

```

Explore the validation report. Can you:

1.  Identify what fail percentage each validation had?
2.  Identify how many rows failed each validation?
3.  View the CSV extracts of failed data?

## Task 2 - Add Action Levels

🔄 Task

Iterate on your agent created for `small_table` and add action levels.
Action levels behave like tags. You can decide what threshold you want
to put for `notify`, `warn`, and `stop`. At a minimum, the tag will
provide a visual indicator of threshold exceedance in the validation
table. You can also use these tags post-interrogation to take actions.

✅ Solution

The action levels can be set as an **integer**, representing the
threshold number of failing units , or a **fraction**, representing the
fraction of failing units.

Use
`actions = action_levels(warn_at = ____, stop_at = ____, notify_at = ____)`
to add action levels to one, some, or all of your validations and rerun
the interrogation to see the output. Some samples have been provided.

```{r}
#| label: validation of inspections_filtered with action levels

agent_with_actions <- create_agent(inspections_filtered) |> 
  # verify inspection ID is between two arbitrary numbers so we can see some failed records
  col_vals_between(columns = inspection_id, 50000, 1000000, 
                   label = "Is the Inspection ID a valid entry?",
                   actions = action_levels(warn_at = 0.1, stop_at = 0.3)) |> 
  # verify license number is greater than 1000
  col_vals_gt(columns = license_number, 1000,
              actions = action_levels(warn_at = 0.015)) |> 
  # verify inspection date is valid
  col_vals_lte(columns = inspection_date, today(),
               label = "Is inspection date in the past?",
               actions = action_levels(notify_at = 0.10)) |> 
  # Now add your own using the validations you defined above!
  ____ |> 
  ____ |> 
  
  interrogate()

agent_with_actions

```

## Task 3 - Remove failing data from the dataset

🔄 Task

Pointblank has identified all of the rows of `inspections_filtered` that
passed and failed validation. Now remove those that failed so the data
that is passed downstream to our modeling step is squeaky clean.

✅ Solution

Pointblank provides a number of [post-interrogation functions](#0) to
work with intel gathered from the validation. For this task, we will
"sunder" the data using `pointblank::get_sundered_data()`.

> **💡 sunder** /sun·der / ˈsən-dər / *verb* \| to split apart

```{r}
#| label: sunder data

# Passed data
inspections_validated <- get_sundered_data(agent = ____,
                                           type = ____)

# Failed data
inspections_failed_validation <- get_sundered_data(agent = ____,
                                        type = ____)

```

## Task 4 - Provide a data dictionary (aka Informant) to explain the data

🔄 Task

Data should never be used blindly. Proper documentation is essential.
Pointblank can generate an `informant` table (OR or data dictionary)
that can provide both static and dynamically-rendered details about your
data.

Create a data dictionary for `inspections_validated`.

✅ Solution

Table information can be synthesized in an information management
workflow, giving us a snapshot of a data table we care to collect
information on. The pointblank informant is fed a series of `info_*()`
functions to define bits of information about a table. This info text
can pertain to individual columns, the table as a whole, and whatever
additional information makes sense for your organization. We can even
glean little snippets of information (like column stats or sample
values) from the target table with `info_snippet()` and the `snip_*()`
functions and mix them into the data dictionary wherever they're needed.

First let's see the bare bones informant table that `pointblank` can
create.

```{r}
#| label: basic informant for inspections_validated

create_informant(
  tbl = inspections_validated
)

```

The bare table already gives a summary of the table size, shape, and
column schema. But Now let's add to this with some `info_*()` functions
to make it more useful. Reference the Informative Functions section of
the `pointblank` documentation:
<https://rstudio.github.io/pointblank/reference/index.html#information-functions>.
A few sections have been provided as examples. Notice that markdown
syntax is supported!

```{r}
#| label: create data dictionary 

create_informant(
  tbl = inspections_validated) |> 
  info_tabular(
    description = "____"
    ) |> 
  info_section(
    section_name = "further information",
    `source` = "Data from City of Chicago, <https://www.cityofchicago.org>",
    `🔄 updates` = 
      "Original data source updated every *Friday*. This table last updated {Sys.Date()}.") |> 
  info_columns(
    columns = inspection_date,
    `Info:` = "The date of the **inspection.**") |>
  # Add your own information to make this table more meaningful.
  ____ |>
  # Using `incorporate` will run any calculations defined within the table
  incorporate()


```
